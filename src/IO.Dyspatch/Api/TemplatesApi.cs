/* 
 * Dyspatch API
 *
 * # Introduction  The Dyspatch API is based on the REST paradigm, and features resource based URLs with standard HTTP response codes to indicate errors. We use standard HTTP authentication and request verbs, and all responses are JSON formatted. See our [Implementation Guide](https://docs.dyspatch.io/development/implementing_dyspatch/) for more details on how to implement Dyspatch.  ## API Client Libraries Dyspatch provides API Clients for popular languages and web frameworks.  - [Java](https://github.com/getdyspatch/dyspatch-java) - [Javascript](https://github.com/getdyspatch/dyspatch-javascript) - [Python](https://github.com/getdyspatch/dyspatch-python) - [C#](https://github.com/getdyspatch/dyspatch-dotnet) - [Go](https://github.com/getdyspatch/dyspatch-golang) - [Ruby](https://github.com/getdyspatch/dyspatch-ruby) 
 *
 * The version of the OpenAPI document: 2020.08
 * Contact: support@dyspatch.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using IO.Dyspatch.Client;
using IO.Dyspatch.Model;

namespace IO.Dyspatch.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITemplatesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Get Template by ID
        /// </summary>
        /// <remarks>
        /// Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>TemplateRead</returns>
        TemplateRead GetTemplateById (string templateId, string targetLanguage, string accept);

        /// <summary>
        /// Get Template by ID
        /// </summary>
        /// <remarks>
        /// Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>ApiResponse of TemplateRead</returns>
        ApiResponse<TemplateRead> GetTemplateByIdWithHttpInfo (string templateId, string targetLanguage, string accept);
        /// <summary>
        /// List Templates
        /// </summary>
        /// <remarks>
        /// Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>TemplatesRead</returns>
        TemplatesRead GetTemplates (string accept, string cursor = default(string));

        /// <summary>
        /// List Templates
        /// </summary>
        /// <remarks>
        /// Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>ApiResponse of TemplatesRead</returns>
        ApiResponse<TemplatesRead> GetTemplatesWithHttpInfo (string accept, string cursor = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITemplatesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Get Template by ID
        /// </summary>
        /// <remarks>
        /// Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>Task of TemplateRead</returns>
        System.Threading.Tasks.Task<TemplateRead> GetTemplateByIdAsync (string templateId, string targetLanguage, string accept);

        /// <summary>
        /// Get Template by ID
        /// </summary>
        /// <remarks>
        /// Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>Task of ApiResponse (TemplateRead)</returns>
        System.Threading.Tasks.Task<ApiResponse<TemplateRead>> GetTemplateByIdAsyncWithHttpInfo (string templateId, string targetLanguage, string accept);
        /// <summary>
        /// List Templates
        /// </summary>
        /// <remarks>
        /// Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>Task of TemplatesRead</returns>
        System.Threading.Tasks.Task<TemplatesRead> GetTemplatesAsync (string accept, string cursor = default(string));

        /// <summary>
        /// List Templates
        /// </summary>
        /// <remarks>
        /// Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </remarks>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>Task of ApiResponse (TemplatesRead)</returns>
        System.Threading.Tasks.Task<ApiResponse<TemplatesRead>> GetTemplatesAsyncWithHttpInfo (string accept, string cursor = default(string));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITemplatesApi : ITemplatesApiSync, ITemplatesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class TemplatesApi : ITemplatesApi
    {
        private IO.Dyspatch.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="TemplatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TemplatesApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TemplatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TemplatesApi(String basePath)
        {
            this.Configuration = IO.Dyspatch.Client.Configuration.MergeConfigurations(
                IO.Dyspatch.Client.GlobalConfiguration.Instance,
                new IO.Dyspatch.Client.Configuration { BasePath = basePath }
            );
            this.Client = new IO.Dyspatch.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new IO.Dyspatch.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = IO.Dyspatch.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TemplatesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public TemplatesApi(IO.Dyspatch.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = IO.Dyspatch.Client.Configuration.MergeConfigurations(
                IO.Dyspatch.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new IO.Dyspatch.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new IO.Dyspatch.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = IO.Dyspatch.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TemplatesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public TemplatesApi(IO.Dyspatch.Client.ISynchronousClient client,IO.Dyspatch.Client.IAsynchronousClient asyncClient, IO.Dyspatch.Client.IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = IO.Dyspatch.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IO.Dyspatch.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public IO.Dyspatch.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Dyspatch.Client.IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Dyspatch.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Get Template by ID Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>TemplateRead</returns>
        public TemplateRead GetTemplateById (string templateId, string targetLanguage, string accept)
        {
             IO.Dyspatch.Client.ApiResponse<TemplateRead> localVarResponse = GetTemplateByIdWithHttpInfo(templateId, targetLanguage, accept);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Template by ID Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>ApiResponse of TemplateRead</returns>
        public IO.Dyspatch.Client.ApiResponse< TemplateRead > GetTemplateByIdWithHttpInfo (string templateId, string targetLanguage, string accept)
        {
            // verify the required parameter 'templateId' is set
            if (templateId == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'templateId' when calling TemplatesApi->GetTemplateById");

            // verify the required parameter 'targetLanguage' is set
            if (targetLanguage == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'targetLanguage' when calling TemplatesApi->GetTemplateById");

            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'accept' when calling TemplatesApi->GetTemplateById");

            IO.Dyspatch.Client.RequestOptions localVarRequestOptions = new IO.Dyspatch.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/vnd.dyspatch.2020.08+json",
                "*/*"
            };

            var localVarContentType = IO.Dyspatch.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = IO.Dyspatch.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("templateId", IO.Dyspatch.Client.ClientUtils.ParameterToString(templateId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(IO.Dyspatch.Client.ClientUtils.ParameterToMultiMap("", "targetLanguage", targetLanguage));
            localVarRequestOptions.HeaderParameters.Add("Accept", IO.Dyspatch.Client.ClientUtils.ParameterToString(accept)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< TemplateRead >("/templates/{templateId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTemplateById", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Template by ID Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>Task of TemplateRead</returns>
        public async System.Threading.Tasks.Task<TemplateRead> GetTemplateByIdAsync (string templateId, string targetLanguage, string accept)
        {
             IO.Dyspatch.Client.ApiResponse<TemplateRead> localVarResponse = await GetTemplateByIdAsyncWithHttpInfo(templateId, targetLanguage, accept);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Template by ID Gets a template object with the matching ID. If the template has published content the \&quot;compiled\&quot; field will contain the template .
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateId">A template ID</param>
        /// <param name="targetLanguage">The type of templating language to compile as. Should only be used for visual templates.</param>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <returns>Task of ApiResponse (TemplateRead)</returns>
        public async System.Threading.Tasks.Task<IO.Dyspatch.Client.ApiResponse<TemplateRead>> GetTemplateByIdAsyncWithHttpInfo (string templateId, string targetLanguage, string accept)
        {
            // verify the required parameter 'templateId' is set
            if (templateId == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'templateId' when calling TemplatesApi->GetTemplateById");

            // verify the required parameter 'targetLanguage' is set
            if (targetLanguage == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'targetLanguage' when calling TemplatesApi->GetTemplateById");

            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'accept' when calling TemplatesApi->GetTemplateById");


            IO.Dyspatch.Client.RequestOptions localVarRequestOptions = new IO.Dyspatch.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/vnd.dyspatch.2020.08+json",
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.PathParameters.Add("templateId", IO.Dyspatch.Client.ClientUtils.ParameterToString(templateId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(IO.Dyspatch.Client.ClientUtils.ParameterToMultiMap("", "targetLanguage", targetLanguage));
            localVarRequestOptions.HeaderParameters.Add("Accept", IO.Dyspatch.Client.ClientUtils.ParameterToString(accept)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<TemplateRead>("/templates/{templateId}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTemplateById", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Templates Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>TemplatesRead</returns>
        public TemplatesRead GetTemplates (string accept, string cursor = default(string))
        {
             IO.Dyspatch.Client.ApiResponse<TemplatesRead> localVarResponse = GetTemplatesWithHttpInfo(accept, cursor);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List Templates Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>ApiResponse of TemplatesRead</returns>
        public IO.Dyspatch.Client.ApiResponse< TemplatesRead > GetTemplatesWithHttpInfo (string accept, string cursor = default(string))
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'accept' when calling TemplatesApi->GetTemplates");

            IO.Dyspatch.Client.RequestOptions localVarRequestOptions = new IO.Dyspatch.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/vnd.dyspatch.2020.08+json",
                "*/*"
            };

            var localVarContentType = IO.Dyspatch.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = IO.Dyspatch.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (cursor != null)
            {
                localVarRequestOptions.QueryParameters.Add(IO.Dyspatch.Client.ClientUtils.ParameterToMultiMap("", "cursor", cursor));
            }
            localVarRequestOptions.HeaderParameters.Add("Accept", IO.Dyspatch.Client.ClientUtils.ParameterToString(accept)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< TemplatesRead >("/templates", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTemplates", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Templates Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>Task of TemplatesRead</returns>
        public async System.Threading.Tasks.Task<TemplatesRead> GetTemplatesAsync (string accept, string cursor = default(string))
        {
             IO.Dyspatch.Client.ApiResponse<TemplatesRead> localVarResponse = await GetTemplatesAsyncWithHttpInfo(accept, cursor);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List Templates Gets a list of Template Metadata objects for all templates. Up to 25 results returned before results are paginated.
        /// </summary>
        /// <exception cref="IO.Dyspatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">A version of the API that should be used for the request. For example, to use version \&quot;2020.08\&quot;, set the value to \&quot;application/vnd.dyspatch.2020.08+json\&quot;</param>
        /// <param name="cursor">A cursor value used to retrieve a specific page from a paginated result set. (optional)</param>
        /// <returns>Task of ApiResponse (TemplatesRead)</returns>
        public async System.Threading.Tasks.Task<IO.Dyspatch.Client.ApiResponse<TemplatesRead>> GetTemplatesAsyncWithHttpInfo (string accept, string cursor = default(string))
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new IO.Dyspatch.Client.ApiException(400, "Missing required parameter 'accept' when calling TemplatesApi->GetTemplates");


            IO.Dyspatch.Client.RequestOptions localVarRequestOptions = new IO.Dyspatch.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/vnd.dyspatch.2020.08+json",
                "*/*"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            if (cursor != null)
            {
                localVarRequestOptions.QueryParameters.Add(IO.Dyspatch.Client.ClientUtils.ParameterToMultiMap("", "cursor", cursor));
            }
            localVarRequestOptions.HeaderParameters.Add("Accept", IO.Dyspatch.Client.ClientUtils.ParameterToString(accept)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<TemplatesRead>("/templates", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTemplates", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
